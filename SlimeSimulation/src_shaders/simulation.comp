#version 450

struct Particle
{
   vec2 pos;
   vec2 vel;
};

layout(std140, binding = 0) buffer Pos 
{
   Particle particles[ ];
};

layout(binding = 1) uniform UBO
{
    float elapsedTime;
    float destX;
    float destY;
    uint particleCount;
} ubo;

vec2 attraction(vec2 particlePos) {
    float attractionConstant = 0.2;
    float attractorMass = 55;
    float massParticle = 10;
    vec2 attractorPos = vec2(ubo.destX, ubo.destY);

    vec2 delta = attractorPos - particlePos;
    float r = clamp(sqrt(dot(delta, delta)), 0.2, 10.0);
    return normalize(delta) * attractionConstant * massParticle * attractorMass / (r * r);
}

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

float rand(vec2 co){
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    // 1D workload 
    uint index = gl_GlobalInvocationID.x;
    if (index > ubo.particleCount) {
        return;
    }

    float massParticle = 10;

    vec2 attractionForce = attraction(particles[index].pos);
    vec2 acceleration = attractionForce / massParticle;

    vec2 vPos = particles[index].pos;
    vec2 vVel = particles[index].vel;

    particles[index].vel = vVel + acceleration * ubo.elapsedTime;

    // collide with boundary
    if ((vPos.x < -1.0) || (vPos.x > 1.0)) {
        particles[index].vel = vec2(-particles[index].vel.x, particles[index].vel.y) * 0.2;
        vVel = vec2(-vVel.x, vVel.y);
    }
    else if ((vPos.y < -1.0) || (vPos.y > 1.0)) {
        particles[index].vel = vec2(particles[index].vel.x, -particles[index].vel.y) * 0.2;
        vVel = vec2(vVel.x, -vVel.y);
    }
    particles[index].pos += vVel * ubo.elapsedTime + 1 / 2 * acceleration * ubo.elapsedTime * ubo.elapsedTime;
}