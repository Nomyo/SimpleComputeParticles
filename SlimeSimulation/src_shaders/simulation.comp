#version 450

struct Particle
{
   vec2 pos;
   vec2 vel;
};

layout(std140, binding = 0) buffer Pos 
{
   Particle particles[ ];
};

layout(binding = 1) uniform UBO
{
    float elapsedTime;
    float destX;
    float destY;
    uint particleCount;
} ubo;

vec2 attraction(vec2 particlePos) {
    float attractionConstant = 15.45;
    float attractorMass = 55;
    vec2 attractorPos = vec2(ubo.destX, ubo.destY);

    vec2 delta = attractorPos - particlePos;
    float r = clamp(sqrt(dot(delta, delta)), 0.5, 10.0);
    return normalize(delta) * attractionConstant * attractorMass / (r * r);
}

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;
void main()
{
    // 1D workload 
    uint index = gl_GlobalInvocationID.x;
    if (index > ubo.particleCount) {
        return;
    }

    float massParticle = 25;

    vec2 attractionForce = attraction(particles[index].pos);
    vec2 acceleration = attractionForce;

    vec2 vPos = particles[index].pos;
    vec2 vVel = particles[index].vel;

    particles[index].vel = vVel + acceleration * ubo.elapsedTime;

	particles[index].vel.x = clamp(particles[index].vel.x, -35.0, 35.0);
	particles[index].vel.y = clamp(particles[index].vel.y, -35.0, 35.0);

	particles[index].pos += vVel * ubo.elapsedTime + 1 / 2 * acceleration * ubo.elapsedTime * ubo.elapsedTime;
	vec2 newPos = particles[index].pos;
    // collide with boundary
	float slowFactor = 0.8;
    if ((newPos.x < -1.0) || (newPos.x > 1.0)) {
        particles[index].vel = vec2(-particles[index].vel.x, particles[index].vel.y) * slowFactor;
		particles[index].pos = vPos + vec2(-vVel.x, vVel.y) * ubo.elapsedTime + 1 / 2 * acceleration * ubo.elapsedTime * ubo.elapsedTime;
    }
    else if ((newPos.y < -1.0) || (newPos.y > 1.0)) {
        particles[index].vel = vec2(particles[index].vel.x, -particles[index].vel.y) * slowFactor;
		particles[index].pos = vPos + vec2(vVel.x, -vVel.y) * ubo.elapsedTime + 1 / 2 * acceleration * ubo.elapsedTime * ubo.elapsedTime;
    }
}